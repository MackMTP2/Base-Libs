Base Libs
---

Base libs is a collection of the most essential libraries - vectors, lines, math, etc - for game development in Lua.
It is developed in active use, *for* active use and will be expanded and refined over time. My primary motives are usability, light weight on both storage and memory with minimal waste of precious CPU cycles.

Vec.lua
---

Vec.lua is a vector class library for game development. It is designed to be loaded like so:

```lua
local Vec = require("Vec")(VECTOR)
```

The function returned by `Vec` returns a local vector lib object, assigns the vector lib object to any variable arguments, and assigns the vector lib object to global context items to locations defined by any string arguments. This vector lib object can then be used to define new vector objects, like so:

```lua
local vec = Vec(0,0)
```

The new vector has an x component of 0 and a y component of 0. The local variable foo becomes the new vector object, and can now be used as such.
The vector library currently supports the following operations through metamethods:

>* (`+`) addition
* (`-`) subtraction
* (`*`) multiplication
* (`/`) division
* (`%`) modulus
* (`^`) power *(this is done vie lua's core ^ operator, which may function differently depending on the implementation)*
* (`..`) dot product
* (`==`) equality check
* (`>`/`<`) greater-than/less-than check
* (`>=`/`<=`) greater-than-or-equal-to/less-than-or-equal-to check
* (`tostring()`) `tostring` function usage

All the math operations return a new vector with the result, thus potentially impacting performance.
The following functions and properties are also supported:

>* `vec.a` returns the angle of the vector from the origin *(`math.atan2(vec.y,vec.x)`)*
* `vec.l` returns the length of the vector *(can be slow when used repeatedly due to use of `math.sqrt()`)*
* `vec.n` returns a unit vector of the same angle *(make suse of `vec.l`, beware!)*
* `vec.max` returns the largest component of the vector *(uses `>`, so negative numbers are considered smaller)*
* `vec.min` returns the smallest component of the vector *(uses `<`, so negative numbers are considered smaller)*
* `vec.r` returns a vector with the components reversed
* `vec.abs` returns a vector with absolute values of the components

>* `vec:dist(vec2)` returns the distance between the vectors
* `vec:copy(dx,dy)` `vec:copy(dv)` copies vec, adding either the delta x and y or the delta vector.
* `vec:dec(vec2)` garbageless shorthand for `vec = vec - vec2`
* `vec:inc(vec2)` garbageless shorthand for `vec = vec + vec2`
* `vec:mul(vec2)` garbageless shorthand for `vec = vec * vec2`
* `vec:div(vec2)` garbageless shorthand for `vec = vec / vec2`
* `vec:mod(vec2)` garbageless shorthand for `vec = vec % vec2`
* `vec:set(vec2)` copies the values of vec2 into vec

* `vec:del()` garbage recycling for vec; pushes vec onto the reuse stack for future vectors to save RAM.

A relatively recent feature, Volatiles, adds the ability to automatically queue vectors for recycling at a controlled time, thus mitigating the garbage pileup from struct math.
(*`_VECTOR` refers to the library object itself*)

>* `_VECTOR.volMode` A boolean setting. Default false. If true, all vectors are automatically marked as 'volatile' upon creation.
* `_Vector.volMath` A boolean setting. Default false. If true, all results of vector math are marked as 'volatile' upon creation.
* `_Vector.crunch()` Recycles all volatile vectors into the delqueue.
* `_Vector.stepCrunch()` Slower per item than crunch(), but deletes only one item at a time. Should be safe for coroutines.
* `vec:vol()` adds vec to the volatile queue.
* `vec:unVol()` Removes vec from volatile queue. Searches from end to beginning, thus making it faster the fewer volatiles are created after vec. Will search entire queue if vec is not volatile, but will not cause any further problems.
* `vec:QUVol()` Only use if you're certain no volatile vectors have been created since vec. Will simply pop the most recent item out of volatiles. Will do nothing if top item is not vec. (*i.e. if vec is not a volatile, or is not the last volatile created*)

An example usage of volatility:
(note: for this application, I would normally recommend use of garbageless functions rather than volatility)

```lua
local Vec = require("Vec")()
local pos,vel,grav = Vec(0,0),Vec(0,0),Vec(0,9.4)
Vec.volMath = true

local intertime = 0.01
local last

function update(dt)
	vel = (vel:del()+grav*dt):QUVol()
	pos = (pos:del()+vel*dt):QUVol()
	last = os.clock()

	while os.clock()-last<intertime do
		Vec.stepCrunch()
	end
end
```

In this example, assuming "update" is called every frame with a delta time argument in seconds (as in such platforms as LOVE), the object represented by "pos" would accelerate at 9.4 "meters" per second, updating both velocity and position. The previous versions of these vectors are deleted, and the garbage generated by mathematics is crunched at a comfortable rate in the time between updates - a hundredth of a second, roughly, as defined by "intertime."

Do still note that this particular case could be accomplished via use of garbageless functions with ease, making it far more efficient, but that such optimization is not always feasible or convenient - i.e. in the case of complex or staged math, or when the result is a separate item.

Rec.lua
---

Rec.lua is a rectangle class library which functions very similarly to Vec.lua, and in fact requires Vec.lua to work. Upon load, it will attempt to load Vec from multiple sources, or use it if there's already a global \_VECTOR variable defined.
Rec.lua is loaded the same as Vec.lua

The constructor is also similar:

```lua
local rec = Rec(0,0,10,10)
```

This creates an axis-aligned rectangle object with its top left corner (bottom left if you're not using inverted y coords) at 0,0 and a width and height of 10 and 10.
These components can be accessed as `rect.x`, `rect.y`, `rect.w`, and `rect.h` respectively.

Rectangle objects support the following properties, which can be both read and written, having operations for both:

>* `rec.l` the left side of the rectangle - returns x, sets x
* `rec.r` the right side of the rectangle - returns x + w, sets x (with offset of w)
* `rec.t` the top side of the rectangle (in inv y) - returns y, sets y
* `rec.b` the bottom side of the rectangle (in inv y) - returns y + h, sets y (with offset of h)
* `rec.mx` the middle x coordinate of the rectangle - returns x + w/2, sets x (with offset of w/2)
* `rec.my` the middle y coordinate of the rectangle - returns y + h/2, sets y (with offset of h/2)
* `rec.pos` the top left vector of the rectangle (in inv y)
* `rec.pos` the top left vector of the rectangle (in inv y)
* `rec.pos1` the top left vector of the rectangle (in inv y)
* `rec.pos2` the top right vector of the rectangle (in inv y)
* `rec.pos3` the bottom right vector of the rectangle (in inv y)
* `rec.pos4` the bottom left vector of the rectangle (in inv y)
* `rec.pos5` the middle vector of the rectangle
* `rec.dims` the dimensions of the rectangle in vector form

The following methods are, of course, read-only:

>* `rec:intersect(rec2)` AABB true/false intersection check
* `rec:relate(rec2)` AABB distances - all negative for intersection, returns: left, right, up, down
* `rec:fullIntersect(rec2)` returns true/false intersection and results from relate
* `rec:intersection(rec2)` *should* return a rectangle representing the intersected area between the two rectangles.
* `rec:expelDir(rec2)` returns direction for AABB expulsion - 1,2,3 or 4 for left, right, up, and down respectively.
* `rec:expel(rec2)` pushes rec out of rec2 in basic AABB manner (nearest side expulsion)
* `rec:fit(rec2, true)` trims rec to fit inside rec2 - if second arg is true, will return a *copy* of rec rather than change the original
* `rec:copy(dx,dy,dw,dh,mod)` copies rec. Will apply deltas if given, will copy unofficial values into `mod` if given a table, and will use the `mod` table rather than create or recycle a new one.
* `rec:multiply(val)` multiplies all values in rec by val, returns a new rectangle with the result.
* `for v in rec:iter(rec2)` iterates rec2 through rec in "stamp" fashion. Developed for use in grid/list-style menus. V is the rectangle representing the current space.
* `rec:regressB(vec)` I'll... update this as soon as I actually remember what the heck this is for...
* `rec:regress(rec2,vec)` This too.

>* `rec:del()` recycles rec in similar fashion to the Vec library

Line.lua
---

(todo)